group = "Output"
display_name = "Decal Base"
output_node = true
render_configs = ["core/stingray_renderer/renderer"]

inputs = {
	"aca690cb-6305-4a2f-bf3d-69183a493db3" = {
		name = "base_color"
		is_required = false
		display_name = "Base Color"
		type = { vector3: ["HAS_BASE_COLOR"] }
		domain = "pixel"
	}

	"ad5e052f-d316-4a0f-8b79-53c38204d61b" = {
		is_required = false
		name = "base_color_opacity"
		display_name = "Base Color Opacity"
		type = { scalar: ["HAS_BASE_COLOR_OPACITY"] }
		domain = "pixel"
	}

	"b1c86408-aacb-4466-b754-ddcf37a3a2c8" = {
		is_required = false
		name = "normal"
		display_name = "Normal"
		type = { vector3: ["HAS_NORMAL"] }
		domain = "pixel"
	}

	"36ba46d2-f6ea-4e60-a428-fdc17c75bc62" = {
		is_required = false
		name = "normal_opacity"
		display_name = "Normal Opacity"
		type = { scalar: ["HAS_NORMAL_OPACITY"] }
		domain = "pixel"
	}

	"7cadc6f1-f753-41c0-9d6d-ca9fb101f144" = {
		is_required = false
		name = "metallic"
		display_name = "Metallic"
		type = { scalar: ["HAS_METALLIC"] }
		domain = "pixel"
	}

	"a4f8a727-49c4-4e69-9c81-7db49ede615f" = {
		is_required = false
		name = "metallic_mask"
		display_name = "Metallic Mask"
		type = { scalar: ["HAS_METALLIC_MASK"] }
		domain = "pixel"
	}

	"27663b0b-d4e1-4978-94cf-e0d392014480" = {
		is_required = false
		name = "metallic_threshold"
		display_name = "Metallic Threshold"
		type = { scalar: ["HAS_METALLIC_THRESHOLD"] }
		domain = "pixel"
	}

	"f6a9f7bc-f229-42ce-9240-146828cbf665" = {
		is_required = false
		name = "roughness"
		display_name = "Roughness"
		type = { scalar: ["HAS_ROUGHNESS"] }
		domain = "pixel"
	}

	"4f652c6a-b5ad-48f3-8525-cdc5cf34aaf3" = {
		is_required = false
		name = "roughness_opacity"
		display_name = "Roughness Opacity"
		type = { scalar: ["HAS_ROUGHNESS_OPACITY"] }
		domain = "pixel"
	}

	"7c1ec98b-14e9-41fb-b356-e881723b8731" = {
		is_required = false
		name = "roughness_mask"
		display_name = "Roughness Mask"
		type = { scalar: ["HAS_ROUGHNESS_MASK"] }
		domain = "pixel"
	}

	"927a23bd-14d7-48a8-9934-04199a82af19" = {
		is_required = false
		name = "roughness_threshold"
		display_name = "Roughness Threshold"
		type = { scalar: ["HAS_ROUGHNESS_THRESHOLD"] }
		domain = "pixel"
	}

	"1164a5ef-4563-4795-b3b5-42825d6df037" = {
		is_required = false
		name = "emissive"
		display_name = "Emissive"
		type = { vector3: ["HAS_EMISSIVE"] }
		domain = "pixel"
	}

	"34259752-b962-4b65-92c3-903a57338519" = {
		name = "mask"
		is_required = false
		display_name = "Mask"
		type = { scalar: ["HAS_MASK"] }
		domain = "pixel"
	}

	"7a9306c6-95ae-4cdb-9fef-0eedacce4e83" = {
		name = "mask_threshold"
		is_required = false
		display_name = "Mask Threshold"
		type = { scalar: ["HAS_MASK_THRESHOLD"] }
		domain = "pixel"
	}

	"59fd1cf4-f736-470d-8510-1dd7c016639e" = {
		is_required = false
		name = "normal_threshold"
		display_name = "Angle Threshold"
		type = { scalar: ["HAS_NORMAL_THRESHOLD"] }
		domain = "pixel"
	}
}

options = {
	"d1a42a54-0794-4d57-9aa0-eb35acb6b35c" = "INSTANCED"
	"2b136447-676e-4943-997b-04a28ae68497" = "WORLD_SPACE_NORMAL"
	"8df1b8f7-17c2-4ae4-8c4e-25517ec1df46" = "TANGENT_BASIS_FROM_SURFACE"
	"d00a0e06-a753-47fd-9ffd-20f091ff7810" = "SOFT_NORMAL_THRESHOLD"

	"d902d6eb-36e4-479f-aac8-10a7afdcbf35" = "GROUP_0"
	"2395c420-550a-41fb-9d06-d6988794dca4" = "GROUP_1"
	"6cc950bc-76c1-43a5-a413-979084d5f841" = "GROUP_2"
	"efb12ce5-bcf8-47ad-94aa-c9094833b2d1" = "GROUP_3"
	"421b1c9b-9eb1-4ca6-9364-99178675c355" = "GROUP_01"
	"81bd528a-a801-452b-b237-3b442c80557e" = "GROUP_02"
	"2c0f5484-4d92-4d38-8e88-972885de2ba4" = "GROUP_13"
	"2f1738ff-75c4-4ccf-8345-6879833536a9" = "GROUP_23"
	"4035efa3-d637-4d4d-865d-24653f90b7a3" = "GROUP_012"
	"82ad5599-11b0-4bf8-bcdf-f77c817f183d" = "GROUP_123"
	"1695f356-fa07-4ccd-b181-9d0e6844570d" = "GROUP_023"
	"cf3416fb-c210-463b-bb8d-0cf789b72e6c" = "GROUP_013"
}

ui = [
	{
		type = "drop_down"
		display_name = "Decal Group"
		options = {
			"None" = "00000000-0000-0000-0000-000000000000"
			"0" 		= "d902d6eb-36e4-479f-aac8-10a7afdcbf35"	
			"1" 		= "2395c420-550a-41fb-9d06-d6988794dca4"
			"2" 		= "6cc950bc-76c1-43a5-a413-979084d5f841"
			"3" 		= "efb12ce5-bcf8-47ad-94aa-c9094833b2d1"
			"0, 1" 	 	= "421b1c9b-9eb1-4ca6-9364-99178675c355"
			"0, 2"	 	= "81bd528a-a801-452b-b237-3b442c80557e"
			"1, 3"	 	= "2c0f5484-4d92-4d38-8e88-972885de2ba4"
			"2, 3" 		= "2f1738ff-75c4-4ccf-8345-6879833536a9"
			"0, 1, 2" 	= "4035efa3-d637-4d4d-865d-24653f90b7a3"
			"1, 2, 3" 	= "82ad5599-11b0-4bf8-bcdf-f77c817f183d"
			"0, 2, 3" 	= "1695f356-fa07-4ccd-b181-9d0e6844570d"
			"0, 1, 3" 	= "cf3416fb-c210-463b-bb8d-0cf789b72e6c"
		}
		default = "00000000-0000-0000-0000-000000000000"
	}

	{
		type = "drop_down"
		display_name = "Normals In"
		options = {
			"Tangent Space" = "00000000-0000-0000-0000-000000000000"
			"World Space"   = "2b136447-676e-4943-997b-04a28ae68497"
		}
		default = "00000000-0000-0000-0000-000000000000"
	}

	{
		type = "drop_down"
		display_name = "Normal Threshold"
		options = {
			"Hard" = "00000000-0000-0000-0000-000000000000"
			"Soft" = "d00a0e06-a753-47fd-9ffd-20f091ff7810"
		}
		default = "00000000-0000-0000-0000-000000000000"
	}

	{
		type = "drop_down"
		display_name = "Tangent Basis From"
		options = {
			"Decal Box" = "00000000-0000-0000-0000-000000000000"
			"Surface"   = "8df1b8f7-17c2-4ae4-8c4e-25517ec1df46"
		}
		default = "00000000-0000-0000-0000-000000000000"
	}

	{ type = "checkbox" display_name = "Instancing" option = "d1a42a54-0794-4d57-9aa0-eb35acb6b35c" }
	
]

render_state = {
	decal_stencil = {
		state: {
		"defined(GROUP_0) || defined(GROUP_1) || defined(GROUP_2) || defined(GROUP_3) ||
			defined(GROUP_01) || defined(GROUP_02) || defined(GROUP_13) || defined(GROUP_23) ||
			defined(GROUP_012) || defined(GROUP_123) || defined(GROUP_023) || defined(GROUP_013)" = {
				stencil_enable = "true"
				stencil_fail = "stencil_op_keep"
				stencil_pass = "stencil_op_keep"
				stencil_z_fail = "stencil_op_keep"

				stencil_fail_back_side = "stencil_op_keep"
				stencil_pass_back_side = "stencil_op_keep"
				stencil_z_fail_back_side = "stencil_op_keep"
				
				stencil_write_mask = "0x0"
			}

			"defined(GROUP_0)" = {
				stencil_func = "equal"
				stencil_func_back_side = "equal"
				stencil_mask = "0x60"
				stencil_ref = "0x0"
			}
			"defined(GROUP_1)" = {
				stencil_func = "equal"
				stencil_func_back_side = "equal" 
				stencil_mask = "0x60"
				stencil_ref = "0x20"
			}
			"defined(GROUP_2)" = {
				stencil_func = "equal"
				stencil_func_back_side = "equal"
				stencil_mask = "0x60"
				stencil_ref = "0x40"
			}
			"defined(GROUP_3)" = {
				stencil_func = "equal"
				stencil_func_back_side = "equal"
				stencil_mask = "0x60"
				stencil_ref = "0x60"
			}
			"defined(GROUP_01)" = {
				stencil_func = "equal"
				stencil_func_back_side = "equal"
				stencil_mask = "0x40"
				stencil_ref = "0x0"
			}
			"defined(GROUP_02)" = {
				stencil_func = "equal"
				stencil_func_back_side = "equal"
				stencil_mask = "0x20"
				stencil_ref = "0x0"
			}
			"defined(GROUP_13)" = {
				stencil_func = "equal"
				stencil_func_back_side = "equal"
				stencil_mask = "0x20"
				stencil_ref = "0x60"
			}
			"defined(GROUP_23)" = {
				stencil_func = "equal"
				stencil_func_back_side = "equal"
				stencil_mask = "0x40"
				stencil_ref = "0x60"
			}
			"defined(GROUP_012)" = {
				stencil_func = "not_equal"
				stencil_func_back_side = "not_equal"
				stencil_mask = "0x60"
				stencil_ref = "0x60"
			}
			"defined(GROUP_123)" = {
				stencil_func = "not_equal"
				stencil_func_back_side = "not_equal"
				stencil_mask = "0x60"
				stencil_ref = "0x0"
			}
			"defined(GROUP_023)" = {
				stencil_func = "not_equal"
				stencil_func_back_side = "not_equal"
				stencil_mask = "0x60"
				stencil_ref = "0x20"
			}
			"defined(GROUP_013)" = {
				stencil_func = "not_equal"
				stencil_func_back_side = "not_equal"
				stencil_mask = "0x60"
				stencil_ref = "0x40"
			}
		}
	}
	
	decal = {
		inherit: ["core/stingray_renderer/shader_libraries/common/common#opacity" "decal_stencil"]
		state: {
			cull_mode = "cull_ccw"
			z_func = "greater_equal"
			z_write_enable = "false"
			
			"defined(HAS_BASE_COLOR)": {
				write_mask0 = "red|green|blue"
			}
			"!defined(HAS_BASE_COLOR)": {
				write_mask0 = "0x0"
			}
			"defined(HAS_NORMAL)": {
				write_mask1 = "red|green|blue"
			} 
			"!defined(HAS_NORMAL)": {
				write_mask1 = "0x0"
			}

			write_mask2 = "0x0"
		}
	}

	decal_roughness = {
		inherit: ["core/stingray_renderer/shader_libraries/common/common#default" "decal_stencil"]
		state: {
			cull_mode = "cull_ccw"
			z_func = "greater_equal"
			z_write_enable = "false"
			
			independent_blend_enable = "true"
			
			write_mask0 = "0x0"
			write_mask1 = "alpha"
			write_mask2 = "0x0"
		}
	}

	decal_metal = {
		inherit: ["core/stingray_renderer/shader_libraries/common/common#default" "decal_stencil"]
		state: {
			cull_mode = "cull_ccw"
			z_func = "greater_equal"
			z_write_enable = "false"
			
			independent_blend_enable = "true"
			
			write_mask0 = "alpha"
			write_mask1 = "0x0"
			write_mask2 = "green"
		}
	}

	emissive = {
		inherit: ["core/stingray_renderer/shader_libraries/common/common#default" "decal_stencil"]
		state: {
			cull_mode = "cull_ccw"
			write_mask0 = "red|green|blue"
			z_write_enable = "false"
			z_func = "greater_equal"
			blend_enable = "true"
			blend_op = "blend_op_add"
			dest_blend = "blend_one"
			src_blend = "blend_one"
		}
	}

	wireframe = {
		inherit: ["core/stingray_renderer/shader_libraries/common/common#wireframe"]
	}
}

sampler_state = {}

channels = {
	/*"defined(NEEDS_TANGENT_SPACE) || (defined(GBUFFER_PASS) && defined(HAS_NORMAL) && !defined(WORLD_SPACE_NORMAL))": {
		"defined(TANGENT_BASIS_FROM_SURFACE)": {
			tsm0 = { type = "float3" domain = "pixel" }
			tsm1 = { type = "float3" domain = "pixel" }
			tsm2 = { type = "float3" domain = "pixel" }
		}
		"!defined(TANGENT_BASIS_FROM_SURFACE)": {
			tsm0 = { type = "float3" domains = ["vertex", "pixel"] }
			tsm1 = { type = "float3" domains = ["vertex", "pixel"] }
			tsm2 = { type = "float3" domain = "pixel" }
		}
	}*/
	"defined(NEEDS_TANGENT_SPACE) || (defined(GBUFFER_PASS) && defined(HAS_NORMAL) && !defined(WORLD_SPACE_NORMAL))": {
		tsm0 = { type = "float3" domain = "pixel" }
		tsm1 = { type = "float3" domain = "pixel" }
		tsm2 = { type = "float3" domain = "pixel" }
	}

	"defined(NEEDS_EYE_VECTOR)": {
		eye_vector = { type = "float3" domain = "pixel" }
	}

	"defined(NEEDS_OBJECT_POSITION)": {
		object_position = { type = "float3" domain = "pixel" }
	}

	"defined(NEEDS_WORLD_SPACE_POSITION)": {
		world_position = { type = "float3" domain = "pixel" }
	}

	"defined(HAS_NORMAL_THRESHOLD)": {
		decal_box_y = { type = "float3" domains = ["vertex", "pixel"] }
	}

	"defined(NEEDS_PIXEL_DEPTH)": {
		pixel_depth = { type = "float" domain = "pixel" }
	}

	//"defined(GBUFFER_PASS) || defined(EMISSIVE_PASS)": {
		w = { type = "float4" domains = ["vertex", "pixel"] }
	//}

	decal_uv = { type = "float2" domain = "pixel" } // TODO:
}

//log_permutations = true
permutation_sets = {
}

shader_contexts = {
	default = {
		passes_sort_mode = "deferred"
		compile_with = [
			{ if: "on_renderer(D3D11, D3D12, GL)" }
		]

		passes = [
			{ if: "defined(HAS_BASE_COLOR) || defined(HAS_NORMAL)" then: [
				{ layer="decals" code_block="decal" defines=["GBUFFER_PASS" "BASE_COLOR_NORMAL_PASS"] render_state="decal" }
			]}
			{ if: "defined(HAS_ROUGHNESS)" then: [
				{ layer="decals" code_block="decal" defines=["GBUFFER_PASS" "ROUGHNESS_PASS"] render_state="decal_roughness" }
			]}
			{ if: "defined(HAS_METALLIC)" then: [
				{ layer="decals" code_block="decal" defines=["GBUFFER_PASS" "METALLIC_PASS"] render_state="decal_metal" }
			]}
			{ if: "defined(HAS_EMISSIVE)" then: [
				{ layer="emissive" code_block="decal" defines=["EMISSIVE_PASS"] render_state="emissive" }
			]}

			{ if: "!on_renderer(GL)" then: [
				{ layer="wireframe" code_block="decal" defines=["WIREFRAME_PASS"] render_state="wireframe" branch_key="dev_wireframe" }
			]}
		]
	}
}

code_blocks = {
	decal_common = {
		code = {
			shared = """
				#if !(defined(RENDERER_GL) && defined(STAGE_VERTEX))
					
					// when debugging edge artefacts, this might be the cause (aka ddy and ddy difference for decal uv)
					// https://bartwronski.com/2015/03/12/fixing-screen-space-deferred-decals/
					inline float2 compute_decal_uv(in float3 op, in float4x4 bounding_volume) {
						#if defined(RENDERER_GL)
							vec2 uv = (op.xz / (vec2(bounding_volume[0].z, bounding_volume[2].z) * 0.5)) * 0.5 + 0.5;
						#else
							float2 uv = (op.xz / (bounding_volume._m20_m22 * 0.5)) * 0.5 + 0.5;
						#endif

						uv.y = 1.0 - uv.y;
						return uv;
					}

					// Reference:
					//    Schuler C., "Normal Mapping without Precomputed Tangents",
					//    Shader X5, pp. 131-140, 2006.
					//
					inline float3x3 tangent_frame(in float3 n, in float3 p, in float2 uv)
					{
						// Get edge vectors of the pixel triangle
						float3 dp1  = ddx(p);
						float3 dp2  = ddy(p);
						float2 duv1 = ddx(uv);
						float2 duv2 = ddy(uv);

						// solve the linear system
						float3 dp2perp  = cross(dp2, n);
						float3 dp1perp  = cross(n, dp1);
						float3 tangent  = dp2perp * duv1.x + dp1perp * duv2.x;
						float3 binormal = dp2perp * duv1.y + dp1perp * duv2.y;

						// construct a scale-invariant frame 
						float invmax = rsqrt(max(dot(tangent,tangent), dot(binormal,binormal)));
						return float3x3(tangent * invmax, binormal * invmax, n);
					}
				#endif
			"""
		}
	}

	decal = {
		include:[
			"core/stingray_renderer/shader_libraries/common/common#common",
			"core/stingray_renderer/shader_libraries/common/common#gbuffer_access",
			"core/stingray_renderer/shader_libraries/common/common#taa_offsets",
			"decal_common"
		]

		instance_data = {
			"on_renderer(D3D11, D3D12) && defined(INSTANCED)" : {
				world = { type = "matrix4x4" }

				"defined(WIREFRAME_PASS)" : {
					dev_wireframe_color = { type = "vector4" }
				}
			}
		}

		samplers = {
			linear_depth = { 
				sampler_state = "core/stingray_renderer/shader_libraries/common/common#clamp_point"
				source = "resource_set"
				slot_name = "linear_depth"
				type = "2d"
			}

			gbuffer0 = {
				sampler_state = "core/stingray_renderer/shader_libraries/common/common#clamp_point"
				source = "resource_set"
				slot_name = "gbuffer0"
				type = "2d"
			}

			gbuffer1 = {
				sampler_state = "core/stingray_renderer/shader_libraries/common/common#clamp_point"
				source = "resource_set"
				slot_name = "gbuffer1"
				type = "2d"
			}
		}

		code = {
			hlsl = """
				#if defined(INSTANCED) && defined(RENDERER_D3D11)
					#define HAS_INSTANCING
				#endif

				#if defined(GBUFFER_PASS) && defined(HAS_NORMAL) && !defined(WORLD_SPACE_NORMAL)
					#define NEEDS_TANGENT_SPACE
				#endif

				#if defined(HAS_NORMAL_THRESHOLD) || (defined(NEEDS_TANGENT_SPACE) && defined(TANGENT_BASIS_FROM_SURFACE)) || defined(HAS_NORMAL)
					#define NEEDS_GBUFFER_NORMAL
				#endif

				#if defined(ROUGHNESS_PASS) && defined(HAS_ROUGHNESS) && defined(HAS_ROUGHNESS_OPACITY)
					#define NEEDS_GBUFFER_ROUGHNESS
				#endif

				#if defined(GBUFFER_PASS) || defined(EMISSIVE_PASS)
					DECLARE_SAMPLER_2D(linear_depth);
					#if defined(NEEDS_GBUFFER_NORMAL) || defined(NEEDS_GBUFFER_ROUGHNESS)
						#if defined(NEEDS_GBUFFER_NORMAL)
							DECLARE_SAMPLER_2D(gbuffer0);
						#endif
						DECLARE_SAMPLER_2D(gbuffer1);
					#endif
				#endif

				struct VS_INPUT {
					float4 position : POSITION;
					GRAPH_VERTEX_INPUT
				};
				
				inline void tspace_transpose(out float3 tsm0, out float3 tsm1, in float3 t, in float3 b, in float3 n) {
					tsm0 = float3(t.x, b.x, n.x);
					tsm1 = float3(t.y, b.y, n.y);
				}
				
				struct PS_INPUT {
					float4 position : SV_POSITION;
					

					// TODO: CAN WE ADD THESE TO THE CHANNEL DATA? SEEMS TO BE A BUG WHEN USING THAT TOGETHER WITH PARALAX node
					#if defined(NEEDS_TANGENT_SPACE) && !defined(TANGENT_BASIS_FROM_SURFACE)
						NO_INTERPOLATION float3 tsm0 : TEXCOORD14;
						NO_INTERPOLATION float3 tsm1 : TEXCOORD15;
						// NO_INTERPOLATION float3 tsm2 : TEXCOORD4; // cross in ps to calculate this instead of exporting
					#endif

					#if defined(HAS_INSTANCING)
						float4 instance_wireframe_color : COLOR0;
					#endif

					GRAPH_PIXEL_INPUT
				};

				CBUFFER_START(c_per_object)
					float4x4 world_view_proj;
					float4x4 world;
					float4x4 inv_world;
					float4x4 bounding_volume;
					float4 dev_wireframe_color;
					GRAPH_MATERIAL_EXPORTS
				CBUFFER_END

				#if defined(HAS_INSTANCING)
					Buffer<float4> idata;
					float ioffset;
				#endif

				inline float3 gbuffer_encode_normal(float3 normal, float4 gbuffer1, half material_id) {
					if (material_id != TRANSLUCENT_MATERIAL_ID)
						return encode_signed_normal(normal);
					
					return float3(encode_octahedron_normal(normal), gbuffer1.b);
				}
			

				DEFAULT_ROOT_SIGNATURE_ATTRIBUTE
				PS_INPUT vs_main(VS_INPUT input
					#if defined(HAS_INSTANCING)
						, uint instance_id : SV_InstanceId
					#endif
					)
				{
					PS_INPUT o;

					GraphVertexParams params;
					GraphVertexResults results;
				
					#if defined(HAS_INSTANCING)
						uint offset = (uint)ioffset + instance_id * IDATA_STRIDE;
						world[0] = idata.Load(offset + IDATA_world + 0);
						world[1] = idata.Load(offset + IDATA_world + 1);
						world[2] = idata.Load(offset + IDATA_world + 2);
						world[3] = idata.Load(offset + IDATA_world + 3);

						#if defined(WIREFRAME_PASS)
							o.instance_wireframe_color = idata.Load(offset + IDATA_dev_wireframe_color);
						#endif
					#endif

					// Write automatic params
					GRAPH_VERTEX_WRITE_PARAMS(params, input);

					// Evaluate all pieces of the graph that should run per-vertex.
					GRAPH_EVALUATE_VERTEX(results, params);

					#if defined(WIREFRAME_PASS) 
						o.position = mul(input.position, world_view_proj);
						return o;
					#else
						#if defined(NEEDS_TANGENT_SPACE) && !defined(TANGENT_BASIS_FROM_SURFACE)
							tspace_transpose(
								o.tsm0, o.tsm1,
								normalize(world._m00_m01_m02),
								normalize(world._m20_m21_m22),
								-normalize(world._m10_m11_m12)
								);
						#endif

						#if defined(HAS_NORMAL_THRESHOLD)
							GRAPH_VERTEX_PARAM(params, decal_box_y) = -normalize(world._m10_m11_m12);
						#endif

						float4 p = mul(input.position, world_view_proj);
						float4 view_space = p / p.w;
						view_space.xy += get_vs_halton_offset(frame_number);
						o.position = view_space * p.w;

						GRAPH_VERTEX_PARAM(params, w) = encode_world_pos(o.position);

						// Write results
						GRAPH_VERTEX_WRITE(o, results, params);
						   
						return o;
					#endif
				}

				#if defined(GBUFFER_PASS)
					#define BASE_COLOR_OPACITY(gbuffer) gbuffer.buffer0.a
					#define NORMAL_OPACITY(gbuffer) gbuffer.buffer1.a

					struct PS_OUTPUT {
						half4 buffer0 : SV_TARGET0;
						half4 buffer1 : SV_TARGET1;
						#if defined(METALLIC_PASS)
							half2 buffer2 : SV_TARGET2;
						#endif
					};
					
					DEFAULT_ROOT_SIGNATURE_ATTRIBUTE
					PS_OUTPUT ps_main(PS_INPUT input)
					{
						PS_OUTPUT o;

						GraphPixelParams params;
						GraphPixelResults graph; 

						GRAPH_PIXEL_WRITE_PARAMS(params, input);

						half2  uv    = input.position.xy/output_rt_size;
						float  depth = gbuffer_decode_depth(TEX2D(linear_depth, uv));
						float3 wp    = decode_world_pos(GRAPH_PIXEL_DATA(input, w), depth);
						float3 op    = mul(float4(wp, 1.0f), inv_world).xyz;

						// Discard pixel out of decal volume
						bool3 inside = ((op > bounding_volume._m00_m01_m02) && (op < bounding_volume._m10_m11_m12));
						if(!all(inside))
							discard;

						#if defined(NEEDS_PIXEL_DEPTH)
							GRAPH_PIXEL_PARAM(params, pixel_depth) = depth;
						#endif

						// Compute graph input data 
						float2 decal_uv = compute_decal_uv(op, bounding_volume);            
						GRAPH_PIXEL_PARAM(params, decal_uv) = decal_uv; 

						// Compute eye vector
						float3 eye_vector = camera_pos - wp;
						#if defined(NEEDS_EYE_VECTOR)
							GRAPH_PIXEL_PARAM(params, eye_vector) = eye_vector;
						#endif

						#if defined(NEEDS_GBUFFER_NORMAL) || defined(NEEDS_GBUFFER_ROUGHNESS)
							half4 gbuffer1_ = TEX2D(gbuffer1, uv);					
						#endif
						#if defined(NEEDS_GBUFFER_NORMAL)
							half4 gbuffer0_ = TEX2D(gbuffer0, uv);
							half material_id = gbuffer_decode_material_id(gbuffer0_);
							float3 gbuffer1_normal = gbuffer_decode_normal(gbuffer1_, material_id);
						#endif
						#if defined(NEEDS_GBUFFER_ROUGHNESS)
							half gbuffer1_roughness = gbuffer_decode_roughness(gbuffer1_);
						#endif

						#if defined(NEEDS_TANGENT_SPACE)
							#if defined(TANGENT_BASIS_FROM_SURFACE)
								float3x3 surface_tbn = tangent_frame(gbuffer1_normal, eye_vector, decal_uv);
								tspace_transpose(
									GRAPH_PIXEL_PARAM(params, tsm0),
									GRAPH_PIXEL_PARAM(params, tsm1),
									GRAPH_PIXEL_PARAM(params, tsm2),
									surface_tbn._m00_m01_m02,
									-surface_tbn._m10_m11_m12,
									surface_tbn._m20_m21_m22
									);
							#else
								GRAPH_PIXEL_PARAM(params, tsm0) = input.tsm0;
								GRAPH_PIXEL_PARAM(params, tsm1) = input.tsm1;
								GRAPH_PIXEL_PARAM(params, tsm2) = cross(input.tsm0, input.tsm1);
							#endif
						#endif

						#if defined(NEEDS_OBJECT_POSITION)
							GRAPH_PIXEL_PARAM(params, object_position) = op;
						#endif

						#if defined(NEEDS_WORLD_SPACE_POSITION)
							GRAPH_PIXEL_PARAM(params, world_position) = wp;
						#endif

						GRAPH_EVALUATE_PIXEL(graph, params);

						#if defined(HAS_MASK)
							#if defined(HAS_MASK_THRESHOLD)
								float mask_threshold = graph.mask_threshold;
							#else
								float mask_threshold = 0.5f;
							#endif
							if (graph.mask <= mask_threshold)
								discard;
						#endif

						float threshold_fade = 1.0;
						#if defined(HAS_NORMAL_THRESHOLD)
							#if defined(SOFT_NORMAL_THRESHOLD)
								threshold_fade = saturate((dot(GRAPH_PIXEL_DATA(input, decal_box_y), gbuffer1_normal) - graph.normal_threshold) / (1.0 - graph.normal_threshold));
							#else
								if (dot(GRAPH_PIXEL_DATA(input, decal_box_y), gbuffer1_normal) < graph.normal_threshold)
									discard;
							#endif
						#endif
						
						// Base color
						#if defined(BASE_COLOR_NORMAL_PASS)
							#if defined(HAS_BASE_COLOR)
								BASE_COLOR(o) = gbuffer_encode_base_color(graph.base_color);
								#if defined(HAS_BASE_COLOR_OPACITY)
									BASE_COLOR_OPACITY(o) = graph.base_color_opacity * threshold_fade;
								#else
									BASE_COLOR_OPACITY(o) = threshold_fade;
								#endif
							#endif

							// Normal
							#if defined(HAS_NORMAL)
								float3 graph_normal = graph.normal;
								#if !defined(WORLD_SPACE_NORMAL)
									graph_normal = rotate_vector3(
										graph_normal,
										GRAPH_PIXEL_PARAM(params, tsm0),
										GRAPH_PIXEL_PARAM(params, tsm1),
										GRAPH_PIXEL_PARAM(params, tsm2)
										);
								#endif

								NORMAL(o) = gbuffer_encode_normal(graph_normal, gbuffer1_, material_id);
								#if defined(HAS_NORMAL_OPACITY)
									NORMAL_OPACITY(o) = graph.normal_opacity * threshold_fade;
								#else
									NORMAL_OPACITY(o) = threshold_fade;
								#endif
							#endif
						#elif defined(ROUGHNESS_PASS)
							#if defined(HAS_ROUGHNESS_MASK)
								#if defined(HAS_ROUGHNESS_THRESHOLD)
									float roughness_threshold = graph.roughness_threshold;
								#else
									float roughness_threshold = 0.5f;
								#endif
								if (graph.roughness_mask * threshold_fade <= roughness_threshold)
									discard;
							#endif

							#if defined(HAS_ROUGHNESS)
								#if defined(HAS_ROUGHNESS_OPACITY)
									ROUGHNESS(o) = gbuffer_encode_roughness(lerp(gbuffer1_roughness, graph.roughness, graph.roughness_opacity));
								#else
									ROUGHNESS(o) = gbuffer_encode_roughness(graph.roughness);
								#endif
							#endif
						#elif defined(METALLIC_PASS)
							#if defined(HAS_METALLIC_MASK)
								#if defined(HAS_METALLIC_THRESHOLD)
									float metallic_threshold = graph.metallic_threshold;
								#else
									float metallic_threshold = 0.5f;
								#endif
								if (graph.metallic_mask * threshold_fade <= metallic_threshold)
									discard;
							#endif
							MATERIAL_ID(o) = gbuffer_encode_material_id();
							METALLIC(o) = gbuffer_encode_metallic_mask(graph.metallic);
						#endif

						return o;
					}
				#elif defined(EMISSIVE_PASS)
					DEFAULT_ROOT_SIGNATURE_ATTRIBUTE
					float4 ps_main(PS_INPUT input) : SV_TARGET0
					{
						GraphPixelParams params;
						GraphPixelResults graph;

						GRAPH_PIXEL_WRITE_PARAMS(params, input);

						half2  uv    = input.position.xy/output_rt_size;
						float  depth = gbuffer_decode_depth(TEX2D(linear_depth, uv));
						float3 wp    = decode_world_pos(GRAPH_PIXEL_DATA(input, w), depth);
						float3 op    = mul(float4(wp, 1.0f), inv_world).xyz;

						// Discard pixel out of decal volume
						bool3 inside = ((op > bounding_volume._m00_m01_m02) && (op < bounding_volume._m10_m11_m12));
						if(!all(inside))
							discard;

						#if defined(NEEDS_PIXEL_DEPTH)
							GRAPH_PIXEL_PARAM(params, pixel_depth) = depth;
						#endif

						// Compute graph input data
						float2 decal_uv = compute_decal_uv(op, bounding_volume);
						GRAPH_PIXEL_PARAM(params, decal_uv) = decal_uv;

						#if defined(NEEDS_OBJECT_POSITION)
							GRAPH_PIXEL_PARAM(params, object_position) = op;
						#endif

						#if defined(NEEDS_WORLD_SPACE_POSITION)
							GRAPH_PIXEL_PARAM(params, world_position) = wp;
						#endif

						// Compute eye vector
						#if defined(NEEDS_EYE_VECTOR)
							float3 eye_vector = camera_pos - wp;
							GRAPH_PIXEL_PARAM(params, eye_vector) = eye_vector;
						#endif

						#if (defined(NEEDS_TANGENT_SPACE) && defined(TANGENT_BASIS_FROM_SURFACE)) || defined(HAS_NORMAL_THRESHOLD)
							half4 gbuffer_1 = TEX2D(gbuffer1, uv);					
							half4 gbuffer_0 = TEX2D(gbuffer0, uv);
							half material_id = gbuffer_decode_material_id(gbuffer_0);
							float3 gbuffer1_normal = gbuffer_decode_normal(gbuffer_1, material_id);
						#endif

						#if defined(NEEDS_TANGENT_SPACE)
							#if defined(TANGENT_BASIS_FROM_SURFACE)
								float3x3 surface_tbn = tangent_frame(gbuffer1_normal, eye_vector, decal_uv);
								tspace_transpose(
									GRAPH_PIXEL_PARAM(params, tsm0), 
									GRAPH_PIXEL_PARAM(params, tsm1),
									GRAPH_PIXEL_PARAM(params, tsm2),
									surface_tbn._m00_m01_m02,
									-surface_tbn._m10_m11_m12,
									surface_tbn._m20_m21_m22
									);
							#else
								GRAPH_PIXEL_PARAM(params, tsm0) = input.tsm0;
								GRAPH_PIXEL_PARAM(params, tsm1) = input.tsm1;
								GRAPH_PIXEL_PARAM(params, tsm2) = cross(input.tsm0, input.tsm1);
							#endif
						#endif

						GRAPH_EVALUATE_PIXEL(graph, params);

						#if defined(HAS_MASK)
							#if defined(HAS_MASK_THRESHOLD)
								float mask_threshold = graph.mask_threshold;
							#else
								float mask_threshold = 0.5f;
							#endif
							if (graph.mask <= mask_threshold)
								discard;
						#endif

						float threshold_fade = 1.0;
						#if defined(HAS_NORMAL_THRESHOLD)
							#if defined(SOFT_NORMAL_THRESHOLD)
								threshold_fade = saturate((dot(GRAPH_PIXEL_DATA(input, decal_box_y), gbuffer1_normal) - graph.normal_threshold) / (1.0 - graph.normal_threshold));
							#else
								if (dot(GRAPH_PIXEL_DATA(input, decal_box_y), gbuffer1_normal) < graph.normal_threshold)
									discard;
							#endif
						#endif
						
						return float4(graph.emissive * threshold_fade, 0.f);
					}
				#elif defined(WIREFRAME_PASS)
					DEFAULT_ROOT_SIGNATURE_ATTRIBUTE
					float4 ps_main(PS_INPUT input) : SV_TARGET0
					{
						#if defined(HAS_INSTANCING)
							return input.instance_wireframe_color;
						#else
							return dev_wireframe_color;
						#endif
					}
				#endif
			"""
		}
	}
}
